import java.util.*;

public class CFGChecker {

    // The grammar in Chomsky Normal Form (CNF)
    // S -> AB | BC
    // A -> a
    // B -> b
    // C -> c
    private static final Map<String, List<String>> grammar = new HashMap<>();

    static {
        // Production rules are stored as a map from the right-hand side to the left-hand side (for reverse lookup)
        grammar.put("AB", List.of("S"));
        grammar.put("BC", List.of("S"));
        grammar.put("a", List.of("A"));
        grammar.put("b", List.of("B"));
        grammar.put("c", List.of("C"));
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("Enter a string to check:");
        String input = scanner.nextLine();

        if (isAcceptedByCFG(input, grammar)) {
            System.out.println("The string \"" + input + "\" is accepted by the CFG.");
        } else {
            System.out.println("The string \"" + input + "\" is NOT accepted by the CFG.");
        }
        scanner.close();
    }

    /**
     * Checks if a string can be generated by a given CFG in Chomsky Normal Form using the CYK algorithm.
     * @param input The string to check.
     * @param grammar The grammar in CNF.
     * @return true if the string is accepted, false otherwise.
     */
    @SuppressWarnings("unchecked")
    public static boolean isAcceptedByCFG(String input, Map<String, List<String>> grammar) {
        int n = input.length();
        if (n == 0) {
            return false; // An empty string is not typically accepted unless there's an S -> epsilon rule, which is not in CNF.
        }

        // DP table: dp[length][start_index] = set of non-terminals that can generate substring
        Set<String>[][] dp = new HashSet[n][n];

        // --- Step 1: Initialize the table for substrings of length 1 (the terminals) ---
        for (int i = 0; i < n; i++) {
            dp[0][i] = new HashSet<>();
            String terminal = String.valueOf(input.charAt(i));
            if (grammar.containsKey(terminal)) {
                dp[0][i].addAll(grammar.get(terminal));
            }
        }

        // --- Step 2: Fill the table for increasing substring lengths (from 2 to n) ---
        for (int len = 2; len <= n; len++) {
            for (int i = 0; i <= n - len; i++) {
                int j = i + len - 1;
                dp[len - 1][i] = new HashSet<>();

                // Iterate through all possible split points
                for (int k = i; k < j; k++) {
                    // Get the sets of non-terminals for the two sub-strings
                    Set<String> set1 = dp[k - i][i];
                    Set<String> set2 = dp[j - k - 1][k + 1];

                    // Find if any combination of non-terminals can form a new non-terminal
                    for (String nt1 : set1) {
                        for (String nt2 : set2) {
                            String combination = nt1 + nt2;
                            if (grammar.containsKey(combination)) {
                                dp[len - 1][i].addAll(grammar.get(combination));
                            }
                        }
                    }
                }
            }
        }

        // --- Step 3: Check the final result ---
        // The string is accepted if the start symbol (S) is in the set for the whole string.
        return dp[n - 1][0].contains("S");
    }
}
